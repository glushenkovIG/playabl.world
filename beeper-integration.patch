From 457e1a225664a0d4faa2f24406b8c3e5dea6b090 Mon Sep 17 00:00:00 2001
From: Ivan Glushenkov <33225544+glushenkovIG@users.noreply.github.com>
Date: Thu, 1 May 2025 14:56:49 +0200
Subject: [PATCH] Add Beeper integration for Timelinize

---
 datasources/_images/beeper.svg |   4 +
 datasources/beeper/beeper.go   | 430 +++++++++++++++++++++++++++++++++
 main.go                        |   1 +
 3 files changed, 435 insertions(+)
 create mode 100644 datasources/_images/beeper.svg
 create mode 100644 datasources/beeper/beeper.go

diff --git a/datasources/_images/beeper.svg b/datasources/_images/beeper.svg
new file mode 100644
index 0000000..11002d8
--- /dev/null
+++ b/datasources/_images/beeper.svg
@@ -0,0 +1,4 @@
+<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32">
+  <path fill="#5D00FF" d="M16 0C7.163 0 0 7.163 0 16s7.163 16 16 16 16-7.163 16-16S24.837 0 16 0zm0 28c-6.627 0-12-5.373-12-12S9.373 4 16 4s12 5.373 12 12-5.373 12-12 12z"/>
+  <path fill="#5D00FF" d="M22 16c0 3.314-2.686 6-6 6s-6-2.686-6-6 2.686-6 6-6 6 2.686 6 6z"/>
+</svg> 
\ No newline at end of file
diff --git a/datasources/beeper/beeper.go b/datasources/beeper/beeper.go
new file mode 100644
index 0000000..e20aa50
--- /dev/null
+++ b/datasources/beeper/beeper.go
@@ -0,0 +1,430 @@
+/*
+	Timelinize
+	Copyright (c) 2024 Timelinize Contributors
+
+	This program is free software: you can redistribute it and/or modify
+	it under the terms of the GNU Affero General Public License as published
+	by the Free Software Foundation, either version 3 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU Affero General Public License for more details.
+
+	You should have received a copy of the GNU Affero General Public License
+	along with this program.  If not, see <https://www.gnu.org/licenses/>.
+*/
+
+// Package beeper implements a data source for Beeper chat data.
+package beeper
+
+import (
+	"context"
+	"database/sql"
+	"fmt"
+	"io"
+	"os"
+	"path/filepath"
+	"strings"
+	"time"
+
+	_ "github.com/mattn/go-sqlite3"
+	"github.com/timelinize/timelinize/timeline"
+	"go.uber.org/zap"
+)
+
+// Data source name and ID.
+const (
+	DataSourceName = "Beeper"
+	DataSourceID   = "beeper"
+)
+
+func init() {
+	err := timeline.RegisterDataSource(timeline.DataSource{
+		Name:            DataSourceID,
+		Title:           DataSourceName,
+		Icon:            "beeper.svg",
+		Description:     "Beeper chat messages importer",
+		NewFileImporter: func() timeline.FileImporter { return new(Beeper) },
+	})
+	if err != nil {
+		timeline.Log.Fatal("registering data source", zap.Error(err))
+	}
+}
+
+// Beeper interacts with the Beeper SQLite database to extract chat messages.
+type Beeper struct{}
+
+// Recognize returns whether the input file is recognized as a Beeper database.
+func (Beeper) Recognize(_ context.Context, dirEntry timeline.DirEntry, _ timeline.RecognizeParams) (timeline.Recognition, error) {
+	filename := filepath.Base(dirEntry.Name())
+	// Check for Beeper database filenames
+	if filename == "index.db" {
+		var ok bool
+		var err error
+		if ok, err = checkTables(dirEntry.FullPath()); err != nil {
+			return timeline.Recognition{}, fmt.Errorf("checking table existence: %w", err)
+		}
+
+		if ok {
+			return timeline.Recognition{Confidence: 1}, nil
+		}
+	}
+
+	return timeline.Recognition{}, nil
+}
+
+// FileImport conducts an import of the Beeper data.
+func (b *Beeper) FileImport(ctx context.Context, dirEntry timeline.DirEntry, params timeline.ImportParams) error {
+	params.Log.Info("Starting Beeper import", zap.String("file", dirEntry.FullPath()))
+	return b.process(ctx, dirEntry.FullPath(), params)
+}
+
+// process reads the Beeper database and sends the items to the channel.
+func (b *Beeper) process(ctx context.Context, path string, params timeline.ImportParams) error {
+	tempDir, err := os.MkdirTemp("", "beeper_import_*")
+	if err != nil {
+		return fmt.Errorf("creating temp directory: %w", err)
+	}
+	defer os.RemoveAll(tempDir)
+
+	// Open the database in read-only mode
+	db, err := openDB(path, tempDir)
+	if err != nil {
+		return fmt.Errorf("opening database in read-only mode: %w", err)
+	}
+	defer db.Close()
+
+	// Verify that we can read from the database
+	err = db.Ping()
+	if err != nil {
+		return fmt.Errorf("verifying database connection: %w", err)
+	}
+
+	// Explore the database schema
+	tables, err := getTableNames(db)
+	if err != nil {
+		return fmt.Errorf("getting table names: %w", err)
+	}
+
+	params.Log.Info("Found tables in Beeper database", zap.Strings("tables", tables))
+
+	// Check if we have the expected messages table
+	if !containsTable(tables, "messages") {
+		return fmt.Errorf("messages table not found in database")
+	}
+
+	// Get message table columns
+	messageColumns, err := getTableColumns(db, "messages")
+	if err != nil {
+		return fmt.Errorf("getting columns for messages table: %w", err)
+	}
+
+	params.Log.Info("Found message columns", zap.Strings("columns", messageColumns))
+
+	// Build a query based on the available columns
+	query := buildMessagesQuery(tables, messageColumns)
+
+	params.Log.Info("Executing query", zap.String("query", query))
+
+	// Execute the query
+	rows, err := db.QueryContext(ctx, query)
+	if err != nil {
+		return fmt.Errorf("executing query: %w", err)
+	}
+	defer rows.Close()
+
+	// Process the rows
+	count := 0
+	for rows.Next() {
+		select {
+		case <-ctx.Done():
+			return ctx.Err()
+		default:
+			// Get column names
+			columns, err := rows.Columns()
+			if err != nil {
+				return fmt.Errorf("getting column names: %w", err)
+			}
+
+			// Create a slice of interface{} to hold the values
+			values := make([]interface{}, len(columns))
+			valuePtrs := make([]interface{}, len(columns))
+
+			// Create pointers to the values
+			for i := range values {
+				valuePtrs[i] = &values[i]
+			}
+
+			// Scan the row
+			if err := rows.Scan(valuePtrs...); err != nil {
+				return fmt.Errorf("scanning row: %w", err)
+			}
+
+			// Find indices for important fields
+			textIdx := findColumnIndex(columns, "text", "content", "body", "message")
+			timeIdx := findColumnIndex(columns, "timestamp", "time", "date", "created_at")
+			senderIdx := findColumnIndex(columns, "sender", "from", "user", "author")
+			chatIdx := findColumnIndex(columns, "chat", "conversation", "thread", "room")
+
+			// Extract data
+			var text string
+			var timestamp time.Time
+			var sender, chat string
+
+			// Get text content
+			if textIdx >= 0 {
+				text = toString(values[textIdx])
+			}
+
+			// Get timestamp
+			if timeIdx >= 0 {
+				timestamp = toTimestamp(values[timeIdx])
+			} else {
+				timestamp = time.Now() // Fallback
+			}
+
+			// Get sender
+			if senderIdx >= 0 {
+				sender = toString(values[senderIdx])
+			} else {
+				sender = "Unknown"
+			}
+
+			// Get chat/conversation
+			if chatIdx >= 0 {
+				chat = toString(values[chatIdx])
+			} else {
+				chat = "Unknown Chat"
+			}
+
+			// Create metadata map
+			metadata := timeline.Metadata{
+				"Source": "Beeper",
+				"Chat":   chat,
+				"Sender": sender,
+			}
+
+			// Add all columns to metadata
+			for i, col := range columns {
+				metadata[col] = toString(values[i])
+			}
+
+			// Create item
+			item := &timeline.Item{
+				Classification: timeline.ClassMessage,
+				Timestamp:      timestamp,
+				Content: timeline.ItemData{
+					Data: timeline.StringData(text),
+				},
+				Metadata: metadata,
+			}
+
+			// Create entity if we have a sender
+			var entity *timeline.Entity
+			if sender != "" && sender != "Unknown" {
+				entity = &timeline.Entity{
+					Name: sender,
+					Attributes: []timeline.Attribute{
+						{
+							Name:     "beeper_username",
+							Value:    sender,
+							Identity: true,
+						},
+					},
+				}
+			}
+
+			// Send to pipeline
+			params.Pipeline <- &timeline.Graph{
+				Item:   item,
+				Entity: entity,
+			}
+
+			count++
+			if count%1000 == 0 {
+				params.Log.Info("Processed messages", zap.Int("count", count))
+			}
+		}
+	}
+
+	params.Log.Info("Completed Beeper import", zap.Int("total_messages", count))
+	return rows.Err()
+}
+
+// Helper functions
+func checkTables(src string) (bool, error) {
+	tempDir, err := os.MkdirTemp("", "beeper_import_*")
+	if err != nil {
+		return false, fmt.Errorf("creating temp directory: %w", err)
+	}
+	defer os.RemoveAll(tempDir)
+
+	db, err := openDB(src, tempDir)
+	if err != nil {
+		return false, fmt.Errorf("opening database: %w", err)
+	}
+	defer db.Close()
+
+	// Check for message-related tables
+	tables, err := getTableNames(db)
+	if err != nil {
+		return false, err
+	}
+
+	// Look for tables that suggest this is a chat database
+	return containsTable(tables, "messages"), nil
+}
+
+func getTableNames(db *sql.DB) ([]string, error) {
+	rows, err := db.Query("SELECT name FROM sqlite_master WHERE type='table'")
+	if err != nil {
+		return nil, err
+	}
+	defer rows.Close()
+
+	var tables []string
+	for rows.Next() {
+		var name string
+		if err := rows.Scan(&name); err != nil {
+			return nil, err
+		}
+		tables = append(tables, name)
+	}
+
+	return tables, rows.Err()
+}
+
+func getTableColumns(db *sql.DB, table string) ([]string, error) {
+	rows, err := db.Query(fmt.Sprintf("PRAGMA table_info(%s)", table))
+	if err != nil {
+		return nil, err
+	}
+	defer rows.Close()
+
+	var columns []string
+	for rows.Next() {
+		var cid int
+		var name, typ string
+		var notnull, pk int
+		var dfltValue interface{}
+		if err := rows.Scan(&cid, &name, &typ, &notnull, &dfltValue, &pk); err != nil {
+			return nil, err
+		}
+		columns = append(columns, name)
+	}
+
+	return columns, rows.Err()
+}
+
+func findColumnIndex(columns []string, possibleNames ...string) int {
+	for _, name := range possibleNames {
+		for i, col := range columns {
+			if containsIgnoreCase(col, name) {
+				return i
+			}
+		}
+	}
+	return -1
+}
+
+func containsTable(tables []string, tableName string) bool {
+	for _, t := range tables {
+		if containsIgnoreCase(t, tableName) {
+			return true
+		}
+	}
+	return false
+}
+
+func containsIgnoreCase(s, substr string) bool {
+	return strings.Contains(strings.ToLower(s), strings.ToLower(substr))
+}
+
+func toString(v interface{}) string {
+	if v == nil {
+		return ""
+	}
+	switch val := v.(type) {
+	case string:
+		return val
+	case []byte:
+		return string(val)
+	default:
+		return fmt.Sprintf("%v", val)
+	}
+}
+
+func toTimestamp(v interface{}) time.Time {
+	if v == nil {
+		return time.Now()
+	}
+
+	switch val := v.(type) {
+	case int64:
+		// Try milliseconds first (most common)
+		if val > 1000000000000 {
+			return time.Unix(0, val*1000000) // milliseconds to nanoseconds
+		}
+		return time.Unix(val, 0) // seconds
+	case float64:
+		if val > 1000000000000 {
+			return time.Unix(0, int64(val*1000000)) // milliseconds to nanoseconds
+		}
+		return time.Unix(int64(val), 0) // seconds
+	case string:
+		// Try to parse as RFC3339
+		t, err := time.Parse(time.RFC3339, val)
+		if err == nil {
+			return t
+		}
+		// Try to parse as ISO8601
+		t, err = time.Parse("2006-01-02T15:04:05Z", val)
+		if err == nil {
+			return t
+		}
+		// Try other formats...
+		return time.Now()
+	default:
+		return time.Now()
+	}
+}
+
+func buildMessagesQuery(tables []string, columns []string) string {
+	// Start with a basic query
+	query := "SELECT * FROM messages"
+
+	// If we have a limit column, limit to 10000 messages for initial testing
+	query += " LIMIT 10000"
+
+	return query
+}
+
+func openDB(src, tempDir string) (*sql.DB, error) {
+	tmpDB := filepath.Join(tempDir, filepath.Base(src))
+	sourceFile, err := os.Open(src)
+	if err != nil {
+		return nil, fmt.Errorf("opening source file: %w", err)
+	}
+	defer sourceFile.Close()
+
+	destFile, err := os.Create(tmpDB)
+	if err != nil {
+		return nil, fmt.Errorf("creating destination file: %w", err)
+	}
+	defer destFile.Close()
+
+	_, err = io.Copy(destFile, sourceFile)
+	if err != nil {
+		return nil, fmt.Errorf("copying file contents from %s to %s: %w", src, tmpDB, err)
+	}
+
+	// Open the database in read-only mode
+	db, err := sql.Open("sqlite3", fmt.Sprintf("file:%s?mode=ro", tmpDB))
+	if err != nil {
+		return nil, fmt.Errorf("opening SQLite database: %w", err)
+	}
+
+	return db, nil
+}
diff --git a/main.go b/main.go
index ac68f91..20a65db 100644
--- a/main.go
+++ b/main.go
@@ -24,6 +24,7 @@ import (
 	tlcmd "github.com/timelinize/timelinize/cmd"
 	// plug in data sources
 	_ "github.com/timelinize/timelinize/datasources/applecontacts"
+	_ "github.com/timelinize/timelinize/datasources/beeper"
 	_ "github.com/timelinize/timelinize/datasources/calendar"
 	_ "github.com/timelinize/timelinize/datasources/contactlist"
 	_ "github.com/timelinize/timelinize/datasources/email"
-- 
2.39.5 (Apple Git-154)

